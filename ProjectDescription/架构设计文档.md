## 需求分析（考虑可行和步骤分解，ToC）
角色扮演 网页 语音聊天
- **角色扮演**：
  LLM的Prompt提示词身份部分在一个聊天中用同一个
- **网页**：
  要有身份验证功能，会员功能（多模态聊天，甩什么都能语音聊天），基础功能（议题二，纯语音聊天）
- **语言聊天**：
  法1. 语音直接转语音的大模型（仅一个大模型）
  法2. 语音识别文本模型+大语言模型+文本生成语音大模型
- **非功能需求**:
  界面美观，响应快，用户使用方便和流畅
## 技术方案选定
个人觉得这是一个ToC的项目，不是ToB的项目，ToB直接严格按需求实现即可，一分钱一分货。ToC的需要考虑吸引用户并适当开取一些付费功能盈利。这是我能想到的ToC盈利的方式。

考虑到可用性和并发性，我决定采用前后端分离架构。

**前端**: Vue3 + TS + ElementPlus。


**后端**:Python Flask +



# Qiniu_Project 项目介绍
下面是一份**架构设计文档**（Architecture Design Doc, ADD），基于你提供的代码与说明梳理而成；我也加入了面向未来的演进建议与明确取舍观点，方便你落地到生产可用的多模态“语音角色扮演 AI”系统。

---

## 0. 背景与目标

本项目旨在构建一个**面向语音交互与角色扮演**的 AI 网页应用：用户可选择角色（如哈利·波特、苏格拉底）、进行语音对话，系统自动提出高价值问题、保持上下文一致性，并呈现具有风格/情感的语音输出；同时支持面试陪练、英语口语练习与“开口即答”的语音助理模式。该定位与项目说明中的产品愿景一致。

> **我的观点（前瞻）**：把“语音即服务”的交互方式做稳、做快，是这类产品的核心竞争力。优先保障端到端对话的**时延**、**稳定性**与**准入门槛（免安装、开箱即用）**，再逐步扩展到知识库、角色库与会员变现。

---

## 1. 架构总览（文字图）

```
[Browser / Frontend]  <—HTTP/WebSocket—>  [Unified API @7210 Flask]
                                                ├── Web子系统 (抓取/索引/搜索, PG + Qdrant + Embedding)
                                                │      ├── PostgreSQL (pages/chunks, pg_trgm)
                                                │      ├── Qdrant 向量库
                                                │      └── Embedding Service @7202 (Qwen-Embedding, micro-batch)
                                                ├── Chat子系统 (聊天记录 + 永久文件)
                                                │      └── File Server @7201 (MySQL元数据 + 本地文件)
                                                ├── Core子系统 (Auth/Users/Membership/Orders/JWT)
                                                │      └── MySQL (用户/会员/订单/审计日志)
                                                ├── LLM Service @7207 (ModelScope/OpenAI兼容)
                                                ├── ASR Service @7205 (SenseVoice, FunASR)
                                                └── TTS Service @7206 (IndexTTS2 推理)
```

* 前端与统一后端（7210）交互；后端内部再调用向量检索、ASR、TTS、文件服务与LLM服务。
* 端口与服务：7201（文件服）、7202（Embedding）、7205（ASR）、7206（TTS）、7207（LLM）、7210（统一API）。

---

## 2. 关键组件与职责

### 2.1 统一后端（Flask，端口 7210）

* 采用 **Blueprint** 划分三大域：

  * **web**：网页抓取、清洗、切块、嵌入、写入 Qdrant、RAG 搜索（vector / lexical / hybrid）。PostgreSQL 持久化 pages/chunks（启用 `pg_trgm`），并维护 trigram 索引。
  * **chat**：聊天记录与文件永久化（桥接 file_server）。采用 JWT 鉴权。
  * **core**：用户注册/登录、密保、重置密码、会员/订单、审计日志（MySQL）。

* 重要实现要点

  * Embedding 调用：默认 `EMB_BASE=http://120.79.25.184:7202`, 路径 `/Qwen3-Embedding-4B`，支持 pooling/normalize/dim/instruction/prefix。启动时会探测维度并确保 Qdrant collection 参数一致（Cosine）。
  * Hybrid 搜索：向量与词法得分归一后按 `alpha` 融合（默认 0.6）。
  * JWT：`iss/type/exp/iat/sub` 校验，`type=access`。密码与密保答案使用 `werkzeug` 哈希。

> **强观点**：统一后端既承担“API Gateway”又处理“管线编排（抓取/索引）”，对可用性有影响。生产建议**把抓取/索引异步化**（队列+worker），并限制 `/web/ingest` 的外网访问，以降低阻塞与SSRF风险（详见 §7）。

---

### 2.2 Embedding Service（7202，Qwen3-Embedding-4B）

* Flask 微服务，支持 **GET/POST**；提供 **micro-batching**、可选量化（bnb4/8）、FlashAttention2/SDPA、维度截断、normalize、cosine 相似度与简易 rerank。
* 默认模型：`Qwen/Qwen3-Embedding-4B`；设备/精度与 batch 行为可通过环境变量调参（`BATCH_MAX_SIZE/BATCH_TIMEOUT_MS`）。

> **强观点**：Embedding 服务是检索性能的“心脏”。建议开启 **FlashAttention2**（若可用）并固定 `MAX_LENGTH`、`pooling=last + normalize=true` 保持与 Qdrant 的相似度几何一致性；同时在生产侧增加**冷启动预热**，避免首批请求抖动。

---

### 2.3 LLM Service（7207）

* 使用 **ModelScope** 的 OpenAI 兼容接口，提供 `/api/chat` 和 `/api/chat/stream`（流式）。当前模型为 `Qwen/Qwen3-Coder-480B-A35B-Instruct`。

> **风险提醒（强观点）**：`MODEL_API_KEY` 目前**硬编码在代码里**，且直接写到了仓库中，属于严重泄密风险；必须迁移至环境变量或机密管理（KMS/Secrets Manager）。

---

### 2.4 ASR Service（7205，SenseVoice/FunASR）

* 提供 `/asr`（整段识别）与 `/asr/stream`（模拟流式）。加载 `SenseVoiceSmall`，使用 VAD 合并片段，返回富转写文本。要求 GPU（`device="cuda:0"`）。

> **强观点**：ASR 端需要控制 **单次音频长度** 与 **并发**（排队/熔断），否则会抢占 GPU 资源导致总体延迟不可控。

---

### 2.5 TTS Service（7206，IndexTTS2）

* `/synthesize` 以 multipart/form-data 传入 `text` + 可选 `prompt_audio`，支持风格选择与采样参数（`temperature/top_p/top_k/num_beams` 等），返回 `audio/wav`。

> **强观点**：当前 TTS 以单文件写盘的形式输出（`outputs/tts_*.wav`），需要定期清理，并加限流/超时控制，避免磁盘/句柄耗尽。

---

### 2.6 File Server（7201）

* 提供**临时**与**永久**两套文件接口，MySQL 存元数据，本地磁盘存文件；限制单用户文件数（20）与总容量（200MB）。
* 统一后端通过 `fs_permanent_upload` 进行永久化，并在上传后再次调用“列表”接口依据 `filename` 反查 `file_id` 组合下载 URL。

> **强观点**：**上传后再列表反查**存在竞态与一致性问题。应在文件服的上传响应中**直接返回 `file_id`**；统一后端即可省去二次查询（见 §10 改进清单）。

---

## 3. 数据与存储

### 3.1 MySQL（Core/Chat/File）

* 核心表：

  * `users`（唯一约束 username/email/phone，密码与密保答案哈希存储）；
  * `chat_history`（记录用户会话与永久化文件 URL）；
  * `membership_info` / `membership_orders`（会员状态与订单）；
  * `user_action_logs`（审计日志）；
  * `user_files` / `user_permanent_files`（文件元数据）。

> **ER（文字版）**：`users (1) ──< chat_history (*)`；`users (1) ──< membership_info (*)`；`users (1) ──< membership_orders (*)`；`users (1) ──< user_files (*)`；`users (1) ──< user_permanent_files (*)`；`users (1) ──< user_action_logs (*)`。

### 3.2 PostgreSQL（Web 抓取与内容片段）

* 表 `pages(id,url,site,title,published_at,fetched_at,lang,html,content,checksum)` 与 `chunks(id,page_id,chunk_index,content,checksum)`；启用 `pg_trgm`，对 `title/content` 建立 GIN 索引。

### 3.3 Qdrant（向量检索）

* Collection：`web_chunks`（Cosine）；Point payload 含 `page_id/url/title`；`id` 采用 `page_id * 1_000_000 + chunk_index`。

---

## 4. 核心业务流程（顺序）

### 4.1 网页抓取/索引 → RAG 检索

1. `/web/bulk_ingest`（或 `/web/ingest`）接收 URL；
2. 抓取 HTML（自定义 UA），`trafilatura` 提取正文，`bs4` 解析标题/语言；
3. 内容按 `CHUNK_SIZE/CHUNK_OVERLAP` 切块 → 调用 Embedding 批量向量化；
4. 写入 PG（pages/chunks）与 Qdrant（points）；
5. 搜索：`/web/search` 支持 `vector/lexical/hybrid`，hybrid 用 `alpha` 融合。

> **强观点**：建议将 **ingest 转为异步任务**（如 Celery/RQ + Redis），并做**去重/更新策略**（基于 checksum 与 `Last-Modified/Etag`）；检索侧加“**去重按 page 粒度**”与“**按站点/时间**过滤”。

### 4.2 语音对话（ASR ↔ LLM ↔ TTS）

* 前端上传音频 → `/asr` 返回文本 → 统一后端拼接上下文并调用 LLM → 将结果文本送 `/synthesize` 生成音频并返回给前端。ASR/TTS 都支持可调参数以平衡风格与速度。

### 4.3 聊天记录永久化

* 统一后端 `POST /chat/api/chat/save`（鉴权）接收前端上传文件（如对话笔记、音频等），代理上传到文件服永久区，组合出 `content_url` 存入 `chat_history`。

---

## 5. 配置与运行参数（要点）

* **统一后端**：`WEB_CONFIG`（PG URL、Embedding 基址与路径、Qdrant URL/Collection、Chunk 策略）；`DB_CONFIG`（MySQL）；JWT `SECRET_KEY/ISS/TLL`；文件服基址。初始启动会**探测嵌入维度并确保 Qdrant collection**。
* **Embedding**：`MODEL_NAME/MAX_LENGTH/BATCH_MAX_SIZE/BATCH_TIMEOUT_MS/ATTN_IMPL/QUANT/DTYPE`；健康与指标接口 `/health` `/metrics`。
* **ASR**：`device="cuda:0"`、`vad_kwargs`、`batch_size_s/merge_length_s` 可按时延调优。
* **TTS**：`DEFAULT_REFS` 风格、采样/解码参数。
* **文件服**：`MAX_FILES=20`、`MAX_TOTAL_SIZE=200MB` 限制。

---

## 6. 安全设计与合规

* **秘密管理**：禁止在代码中硬编码 API Key 与数据库口令；采用环境变量+容器密文文件或云 KMS。当前 LLM Service 存在硬编码风险，必须修复。
* **JWT**：启用强随机 `SECRET_KEY`，区分 `access/reset` 类型，缩短 TTL，服务端记录 token 黑名单以应对撤销场景。
* **SSRF/出网控制**：`/web/ingest` 的抓取功能应限制白名单域名、拒绝内网地址与 file://、IP 直连，避免 SSRF。
* **上传安全**：文件服使用 `secure_filename`，但仍需限制 MIME/扩展名、扫描恶意内容；永久区与临时区应隔离。
* **审计与留痕**：`user_action_logs` 已有基础埋点；建议记录鉴权失败、限流触发、ASR/TTS 错误码等关键事件。

---

## 7. 可观测性与SLO

* **健康检查**：

  * 统一后端：`/web/health` `/chat/healthz` `/core/healthz`；
  * Embedding：`/health` `/metrics`；
  * ASR/TTS/LLM/File：各自 `/health`。
* **指标建议**：

  * P99 请求时延（ASR、TTS、LLM、RAG 各段），队列长度（Embedding micro-batch），GPU 显存；
  * 失败率/超时率；入库/召回量与平均向量相似度。
* **SLO（初版主张）**：端到端语音轮次首包 < 2.0s，尾包 < 5.0s；日常峰值错误率 < 1%。

---

## 8. 性能与容量

* **Embedding**：micro-batching（默认 16 条/等待 8ms）可显著提升吞吐；在 GPU 充裕时放宽 batch，在负载高时适当提高 timeout，避免频繁小批次。
* **RAG**：Qdrant topK 建议 10~20，融合时 `alpha` 0.5~0.7；PG trigram 适合短文本匹配，长文建议加全文检索（PG FTS）或召回后重排。
* **ASR/TTS/LLM**：GPU 资源隔离；ASR 与 TTS 可分配不同卡避免互相争抢；LLM 走云推理避免本地干扰。

---

## 9. 已知问题与技术债（务必修复）

1. **/web/search 中 Qdrant 调用变量未定义**：代码中使用 `client.query_points` 与 `QDRANT_COLLECTION`，但未在作用域内定义；应改为 `get_qdrant().query_points(collection_name=WEB_CONFIG["QDRANT_COLLECTION"], query_vector=qvec, ...)` 与正确的参数名（`query_vector`）。
2. **LLM API Key 硬编码**：迁移到环境变量，且上线前替换。
3. **文件永久化二次查询**：文件服上传接口应返回 `file_id`，统一后端避免“先传后列”的竞态。
4. **/web/ingest 安全**：缺 SSRF 防护（禁止内网/环回/元数据地址）、缺抓取超时/重试与 MIME/大小限制。
5. **TTS 输出文件清理**：长期积累风险，需周期清理或改为内存/临时文件并在响应后删除。

---

## 10. 架构演进与落地建议（强观点）

* **消息化与解耦**：把“抓取→清洗→切块→嵌入→入库”改造为异步流水线（队列 + 工作进程），统一后端只负责编排与查询。
* **统一鉴权网关**：把 ASR/TTS/LLM/File 置于内网，仅对统一后端开放；对外只暴露 7210，减少攻击面。
* **RAG 质量**：增加查询改写（Query Rewriting）与轻量重排（可直接用 Embedding 的 `/rerank` 接口），显著提升命中质量。
* **会话一致性**：在 Chat 域增加**短期记忆**结构（如最近 N 轮对话摘要）与**用户偏好画像**表，提高角色扮演的一致性与个性化。
* **延迟治理**：ASR/LLM/TTS 全链路**流式化**（前端 WebSocket + 后端边生成边下发），优先首包体验（把“思考”变成“回声”）。
* **前端资源**：`frontend.zip` 未审阅，建议前后端以**约定式 API**对齐（OpenAPI/JSON Schema），方便 Mock 与回归。

---

## 11. 与产品目标的映射

* **角色扮演三要素**

  1. 自动识别可深挖话题 → 由 LLM 负责（可在系统模板里加入“提出 1~2 个高价值追问”的约束），配合 RAG 提供更实证的讨论。
  2. 前后文一致性 → Chat 子系统 + 短期记忆/摘要机制。
  3. 语音风格/情感 → TTS 端通过参考音频与情感参数实现；ASR 侧做高质转写与断句。

* **P0/P1 功能落地**：

  * 语音文字聊天（ASR/LLM/TTS/前端）与聊天记录保存（Chat + File）；
  * 身份认证/会员变现（Core + MySQL）。

---

## 12. 接口与端口（速查表）

| 域           |   端口 | 关键路径                                                                                               |
| ----------- | ---: | -------------------------------------------------------------------------------------------------- |
| Unified API | 7210 | `/web/ingest`, `/web/search`, `/web/page`, `/chat/api/chat/*`, `/api/auth/*`, `/api/membership/*`  |
| Embedding   | 7202 | `GET/POST /Qwen3-Embedding-4B`, `/similarity`, `/rerank`, `/health`                                |
| LLM         | 7207 | `POST /api/chat`, `POST /api/chat/stream`, `/health`                                               |
| ASR         | 7205 | `POST /asr`, `POST /asr/stream`                                                                    |
| TTS         | 7206 | `POST /synthesize`, `/health`                                                                      |
| File Server | 7201 | `/upload/{user}`, `/download/{file}`, `/permanent/upload/{user}`, `/permanent/download/{file}`     |

---

## 13. 部署与拓扑（建议）

* **容器化**：每个服务独立容器（统一后端、embedding、asr、tts、file、qdrant、pg、mysql）。
* **网络**：仅暴露统一后端（与前端）和必要的健康探针；其余服务内网访问。
* **数据库**：PG 与 MySQL 独立实例，Qdrant 单独容器；设置持久卷。
* **启动顺序**：DB/Qdrant → Embedding → 统一后端（其会在启动时 probe dim 与 ensure collection）。

---

## 14. 结语

这套架构已经覆盖了**角色扮演 + 语音对话**的最小闭环：ASR → LLM → TTS，并且具备可扩展的 RAG 搜索与会员体系。把**安全（密钥/SSRF/上传）**与**延迟（流式/异步化）**两个横切能力做好，就能把“能用”变成“好用”。接下来非常自然的延展是输出**API 总文档**与**部署运行手册**，同时将抓取与索引拆成可靠的后台流水线，撑起更大的角色库与知识面。
